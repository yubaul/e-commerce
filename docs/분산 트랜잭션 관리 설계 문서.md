# 분산 트랜잭션 관리 설계 문서
### Database per Service 환경에서의 접근 방식

---

## 1. 개요
MSA 환경에서는 각 서비스가 독립적인 데이터베이스(Database per Service)를 가집니다.  
이 구조는 확장성과 독립 배포, 장애 격리에 유리하지만, 기존의 로컬 트랜잭션만으로는 서비스 간 데이터 정합성을 보장하기 어렵습니다.

따라서 본 문서는 **Database per Service 환경에서 분산 트랜잭션의 문제점**을 진단하고,  
**Saga 패턴, Outbox 패턴, 이벤트 기반 아키텍처**를 활용해 안정성을 확보하는 방안을 제시합니다.

---

## 2. 문제 진단
- **단일 DB 환경**
    - 하나의 트랜잭션으로 ACID를 보장할 수 있습니다.
    - 장애 전파나 데이터 불일치 가능성이 낮습니다.
- **Database per Service 전환 후**
    - 전역 트랜잭션 불가 (2PC는 성능 저하 및 운영 복잡성 심각)
    - 서비스 간 동기 호출 시 결합도가 증가하여 한 서비스의 장애가 연쇄 전파됩니다.
    - 주문 성공 후 결제 실패, 재고 차감과 쿠폰 발급 불일치 등 데이터 정합성 문제가 발생할 수 있습니다.

---

## 3. 대응 전략

### 3.1 Saga 패턴 (Choreography 기반)
- 코레오그래피 방식은 중앙 조정자 없이 각 서비스가 이벤트를 발행하고 소비하면서 자체적으로 트랜잭션을 이어갑니다.
- 예시: `OrderPlaced` → Inventory → `StockReserved` → Payment → `PaymentAuthorized` → Order → `OrderCompleted`
- 장점
    - 확장성과 독립성이 뛰어납니다.
    - 새로운 서비스 추가/삭제가 용이합니다.
- 단점
    - 이벤트 흐름이 분산되어 추적과 디버깅이 어렵습니다.
    - 보상 트랜잭션 설계가 복잡합니다.

### 3.2 Outbox 패턴
- 각 서비스는 비즈니스 데이터와 Outbox 이벤트를 하나의 로컬 트랜잭션에서 커밋하여 원자성을 확보합니다.
- Outbox는 INSERT 전용이며, 다른 서비스의 Outbox는 수정하지 않습니다.

#### 주문 서비스 Outbox 테이블
```sql
CREATE TABLE order_outbox_event (
  id            CHAR(36) PRIMARY KEY,
  aggregate_id   VARCHAR(128) NOT NULL,
  type           VARCHAR(128) NOT NULL,
  payload        MEDIUMTEXT NOT NULL,
  headers        TEXT NULL,
  occurred_at    TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  status         VARCHAR(20) NOT NULL DEFAULT 'PENDING',
  retry_count    SMALLINT UNSIGNED NOT NULL DEFAULT 0,
  last_error     TEXT NULL,
  published_at   TIMESTAMP(3) NULL
);
```

#### 재고 서비스 Outbox 테이블
```sql
CREATE TABLE inventory_outbox_event (
  id            CHAR(36) PRIMARY KEY,
  aggregate_id   VARCHAR(128) NOT NULL,
  type           VARCHAR(128) NOT NULL,
  payload        MEDIUMTEXT NOT NULL,
  headers        TEXT NULL,
  occurred_at    TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  status         VARCHAR(20) NOT NULL DEFAULT 'PENDING',
  retry_count    SMALLINT UNSIGNED NOT NULL DEFAULT 0,
  last_error     TEXT NULL,
  published_at   TIMESTAMP(3) NULL
);
```

#### 결제 서비스 Outbox 테이블
```sql
CREATE TABLE payment_outbox_event (
  id            CHAR(36) PRIMARY KEY,
  aggregate_id   VARCHAR(128) NOT NULL,
  type           VARCHAR(128) NOT NULL,
  payload        MEDIUMTEXT NOT NULL,
  headers        TEXT NULL,
  occurred_at    TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  status         VARCHAR(20) NOT NULL DEFAULT 'PENDING',
  retry_count    SMALLINT UNSIGNED NOT NULL DEFAULT 0,
  last_error     TEXT NULL,
  published_at   TIMESTAMP(3) NULL
);
```

### 3.3 보상 트랜잭션
- 실패 시 정방향과 반대되는 이벤트를 발행하여 상태를 복구합니다.
- 예시: 결제 실패 → `PaymentFailed` 발행 → Inventory가 `StockRelease` 이벤트 발행 → Order가 주문 FAILED로 전이합니다.

### 3.4 순서 보장 (Kafka 파티션)
- Kafka는 파티션 단위로 순서를 보장합니다.
- 파티션 키를 `orderId`로 고정하여 같은 주문의 이벤트는 항상 같은 파티션에서 순서대로 처리됩니다.
- 다른 주문은 병렬 처리되므로 성능과 순서 보장을 동시에 만족합니다.

---

## 4. 프론트엔드 응답 전략
- 주문 생성 시: 주문 저장과 Outbox INSERT 후 즉시 `{orderId, status:PENDING}` 반환합니다.
- 이후 상태 전파는 SSE/WebSocket/폴링 방식으로 Order 서비스가 push합니다.
- 프론트엔드는 Kafka나 Debezium을 직접 보지 않고, Order 서비스 API를 통해 최종 상태를 확인합니다.

---

## 5. 운영 고려
- **재시도 및 백오프**
    - Outbox에서 PENDING 또는 FAILED 상태의 이벤트는 워커가 주기적으로 재시도합니다.
    - 지수 백오프를 적용하고, 임계치를 넘으면 DLQ로 이동시킵니다.
- **모니터링 지표**
    - Outbox 큐 길이, 이벤트 지연 시간, Kafka consumer lag, 보상 이벤트 발생률, 사가 타임아웃 발생 건수
- **아카이빙**
    - Outbox 이벤트는 일정 기간 이후 별도 테이블이나 스토리지로 아카이빙하여 실시간 성능 저하를 방지합니다.

---

## 6. 결론
Database per Service 환경에서의 분산 트랜잭션은  
**로컬 트랜잭션 + Outbox + Saga(코레오그래피) + 이벤트 기반 아키텍처** 조합으로 관리됩니다.

- 즉시 일관성 대신 **종단 일관성(Eventual Consistency)**을 채택합니다.
- 실패 시 각 서비스는 보상 이벤트를 발행하여 정합성을 회복합니다.
- 파티션 키 기반 순서 보장으로 보상 트랜잭션까지 안정적으로 처리됩니다.
- 프론트엔드는 오직 Order 서비스를 통해 최종 상태를 확인합니다.

이 아키텍처는 서비스 간 결합도를 최소화하면서도 확장성과 안정성을 확보할 수 있으며,  
대규모 이커머스 환경에서도 견고하게 동작할 수 있습니다.