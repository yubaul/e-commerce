# 동시성 제어 보고서

## 개요

계좌 충전/차감, 재고 차감, 쿠폰 발급/사용 등 다양한 도메인에서의 동시 요청 처리 과정에서  
발생할 수 있는 동시성 이슈를 식별하고, 각 상황에 적합한 트랜잭션 설정 및 락 전략을 기반으로  
데이터 정합성을 확보하기 위한 설계 방향을 정리한 자료입니다.

---

## 1. 계좌 API - 잔액 충전

- 격리 수준(Isolation Level): `REPEATABLE READ`
- 트랜잭션 전파 수준(Propagation): `REQUIRED`

### 문제 상황: Lost Update

동일 계좌에 대해 여러 사용자가 동시에 충전 요청을 보내는 경우,  
각 트랜잭션이 같은 시점의 잔액을 기준으로 연산을 수행하고 커밋하게 되면  
마지막에 커밋된 트랜잭션의 결과만 반영되어 일부 금액이 누락될 수 있습니다.

예:
- Tx1 → 잔액 10,000 + 2,000
- Tx2 → 잔액 10,000 + 5,000
- Tx2가 마지막에 커밋 → 최종 잔액이 17,000이어야 하지만 15,000만 반영되는 상황

### 해결 방안

- `SELECT ... FOR UPDATE`를 활용한 비관적 락 적용
- 트랜잭션 동안 해당 계좌 row에 대해 배타적 접근을 보장하여 충돌 방지

### 장단점 분석

- 장점: 금전 데이터의 정확성을 우선시할 수 있음
- 단점: 트래픽 집중 시 락 대기로 처리 지연 가능

---
## 2. 쿠폰 API - 선착순 쿠폰 발급

- 격리 수준(Isolation Level): `REPEATABLE READ`
- 트랜잭션 전파 수준(Propagation): `REQUIRED`

### 문제 상황: Lost Update

여러 사용자가 동시에 동일 쿠폰을 발급 요청할 경우,  
사용자 보유 여부를 조회한 직후 발급이 이루어지는 구조에서는  
선행 트랜잭션이 아직 커밋되지 않은 상태에서 후행 트랜잭션도 동일한 쿠폰을 발급할 수 있어  
중복 발급이 발생할 가능성이 있습니다.

### 해결 방안

- 사용자 ID + 쿠폰 ID에 대한 **DB 제약조건(UNIQUE)** 설정
- insert 시 중복 예외가 발생하면 애플리케이션 단에서 `DuplicateCouponIssueException` 처리
- 낙관적 락(`version`)은 수량 차감을 위한 동시성 제어용으로 적용
- 충돌 발생 시 최대 3~5회 재시도 + 예외 메시지 처리

#### DDL (UNIQUE 제약조건 추가)

```sql
ALTER TABLE user_coupon
ADD CONSTRAINT uk_user_coupon UNIQUE (user_id, coupon_id);
```

### 장단점 분석

- 장점:
  - 중복 발급을 DB 차원에서 안정적으로 방지 가능
  - 락 경합 없이 응답 속도 확보
- 단점:
  - 중복 발급 예외가 빈번히 발생하는 경우 커넥션 풀 또는 로그 과다 발생 가능성 있음

### 선택 배경

- 선착순 쿠폰은 짧은 시간 내 많은 요청이 집중되는 특성이 있어  
  비관적 락보다는 낙관적 락 + 제약조건 기반의 예외 처리 방식이  
  성능과 안정성 측면에서 균형 잡힌 접근이라고 판단하였습니다.

---

## 3. 주문 API

주문 처리 과정에서는 다음과 같은 동시성 문제가 발생할 수 있습니다:

1. 상품 재고 차감
2. 쿠폰 사용
3. 결제 및 계좌 잔액 차감

---

### 3.1 재고 차감

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRED`

### 문제 상황: Lost Update

여러 주문이 동시에 발생하면 동일 상품의 재고를 기준으로 각각 차감 연산을 수행하게 되며,  
커밋 순서에 따라 일부 연산이 반영되지 않는 문제가 발생할 수 있습니다.

### 해결 방안

- `SELECT ... FOR UPDATE` 기반의 비관적 락 적용
- 조회 및 차감 연산을 하나의 트랜잭션 안에서 수행

### 장단점 분석

- 장점: 실시간 재고 정합성 보장
- 단점: 특정 상품에 대한 집중 요청 시 락 경합 발생 가능

---

### 3.2 쿠폰 사용

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRED`

### 문제 상황: Lost Update 및 Dirty Write

동일 쿠폰을 여러 트랜잭션이 동시에 사용하는 상황에서  
사용 상태(`used`)에 대한 중복 갱신이 발생할 수 있습니다.

### 해결 방안

- 낙관적 락을 적용하여 중복 사용 방지
- 충돌 발생 시 재시도, 일정 횟수 초과 시 예외 처리

### 장단점 분석

- 장점: 빠른 처리 가능, 락 대기 없음
- 단점: 충돌 시 재시도로 인한 커넥션 사용 증가

---

### 3.3 계좌 잔액 차감

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRED`

### 문제 상황: Lost Update

여러 결제 요청이 동시에 들어오면  
잔액 차감 연산이 중복될 수 있고, 일부 내역이 누락될 수 있습니다.

### 해결 방안

- `SELECT ... FOR UPDATE`를 통한 row-level 락 적용
- 조회, 차감, 저장을 하나의 트랜잭션으로 구성하여 원자성 확보

### 장단점 분석

- 장점: 금융 도메인의 데이터 정합성 확보 가능
- 단점: 트래픽 증가 시 처리량 저하 발생 여지 있음

---

## 주문 트랜잭션 흐름 설계

1. 재고 차감 (`FOR UPDATE`)
2. 쿠폰 사용 (`version` 기반 낙관적 락)
3. 주문 생성
3. 생성된 주문 전체 금액 계좌 차감 (`FOR UPDATE`)
4. 결제 내역 저장

### 예외 처리 흐름

- 재고 차감 실패 시 쿠폰 사용 트랜잭션 롤백
- 쿠폰 사용 실패 시 전체 주문 롤백
- 잔액 부족 시 전체 주문/결제 롤백

---

## 추가 고려 사항

- 쿠폰과 같은 독립 처리 가능 도메인은 `REQUIRES_NEW` 트랜잭션 분리 고려
- 낙관적 락 충돌 대비 exponential backoff 전략 적용 가능
- 장애 대응을 위한 충돌/락 경합 지표 로깅 고려

---

## 결론

각 도메인의 트랜잭션 특성과 트래픽 패턴에 따라  
비관적 락과 낙관적 락을 적절히 혼용하여 데이터 정합성을 확보하였습니다.  
복잡한 연계 상황 속에서도 핵심 데이터의 안정성을 보장할 수 있도록  
트랜잭션 흐름과 예외 처리 전략을 유연하게 설계한 것이 이번 구조의 핵심입니다.