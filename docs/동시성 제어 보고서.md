# 동시성 제어 보고서

## 개요

계좌 충전/차감, 재고 차감, 쿠폰 발급/사용 등 다양한 도메인에서의 동시 요청 처리 과정에서  
발생할 수 있는 동시성 이슈를 식별하고, 각 상황에 적합한 트랜잭션 설정 및 락 전략을 기반으로  
데이터 정합성을 확보하기 위한 설계 방향을 정리한 자료입니다.

---

## 1. 계좌 API - 잔액 충전

- 격리 수준(Isolation Level): `REPEATABLE READ`
- 트랜잭션 전파 수준(Propagation): `REQUIRED`

### 문제 상황: Lost Update

동일 계좌에 대해 여러 사용자가 동시에 충전 요청을 보내는 경우,  
각 트랜잭션이 같은 시점의 잔액을 기준으로 연산을 수행하고 커밋하게 되면  
마지막에 커밋된 트랜잭션의 결과만 반영되어 일부 금액이 누락될 수 있습니다.

예:
- Tx1 → 잔액 10,000 + 2,000
- Tx2 → 잔액 10,000 + 5,000
- Tx2가 마지막에 커밋 → 최종 잔액이 17,000이어야 하지만 15,000만 반영되는 상황

### 해결 방안

- `SELECT ... FOR UPDATE`를 활용한 비관적 락 적용
- 트랜잭션 동안 해당 계좌 row에 대해 배타적 접근을 보장하여 충돌 방지

### 장단점 분석

- 장점: 금전 데이터의 정확성을 우선시할 수 있음
- 단점: 트래픽 집중 시 락 대기로 처리 지연 가능

---
## 2. 쿠폰 API - 선착순 쿠폰 발급

- 격리 수준(Isolation Level): `REPEATABLE READ`
- 트랜잭션 전파 수준(Propagation): `REQUIRED`

### 문제 상황: Lost Update

여러 사용자가 동시에 동일 쿠폰을 발급 요청할 경우,  
사용자 보유 여부를 조회한 직후 발급이 이루어지는 구조에서는  
선행 트랜잭션이 아직 커밋되지 않은 상태에서 후행 트랜잭션도 동일한 쿠폰을 발급할 수 있어  
중복 발급이 발생할 가능성이 있습니다.

### 해결 방안

- 사용자 ID + 쿠폰 ID에 대한 DB 제약조건(UNIQUE) 설정
- insert 시 중복 예외가 발생하면 애플리케이션 단에서 DuplicateCouponIssueException 처리
- 수량 차감은 낙관적 락 대신 SELECT ... FOR UPDATE를 적용한 비관적 락 방식으로 변경
- 중복 발급 방지와 재고 동시 차감 문제를 동시에 해결

#### DDL (UNIQUE 제약조건 추가)

```sql
ALTER TABLE user_coupon
ADD CONSTRAINT uk_user_coupon UNIQUE (user_id, coupon_id);
```

### 장단점 분석

- 장점:
  - 중복 발급을 DB 차원에서 안정적으로 방지 가능합니다.
  - 수량 차감도 비관적 락을 통해 강력하게 제어합니다.
- 단점:
  - 트래픽 증가 시 락 대기 시간이 늘어날 수 있습니다.

### 선택 배경

- 기에는 수량 차감에 낙관적 락을 적용하고 @Retryable로 충돌을 방어하려 했으나,
  요청 타이밍과 충돌 빈도에 따라 제어 실패 사례가 발생했으며
  사용자 경험 측면에서 예외 발생 빈도 또한 높아졌습니다.

- 따라서 안정적 처리를 위해 비관적 락 방식으로 전환했습니다.

---

## 3. 주문 API

주문 처리 과정에서는 다음과 같은 동시성 문제가 발생할 수 있습니다:

1. 상품 재고 차감
2. 쿠폰 사용
3. 결제 및 계좌 잔액 차감

---

### 3.1 재고 차감

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRED`

### 문제 상황: Lost Update

여러 주문이 동시에 발생하면 동일 상품의 재고를 기준으로 각각 차감 연산을 수행하게 되며,  
커밋 순서에 따라 일부 연산이 반영되지 않는 문제가 발생할 수 있습니다.

### 해결 방안

- `SELECT ... FOR UPDATE` 기반의 비관적 락 적용
- 조회 및 차감 연산을 하나의 트랜잭션 안에서 수행

### 장단점 분석

- 장점: 실시간 재고 정합성 보장
- 단점: 특정 상품에 대한 집중 요청 시 락 경합 발생 가능

---

### 3.2 쿠폰 사용

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRES_NEW로 변경`
- 전파 수준: `REQUIRED로 재변경`

### 문제 상황: Lost Update 및 Dirty Write

동일 쿠폰을 여러 트랜잭션이 동시에 사용하는 상황에서  
사용 상태(`used`)에 대한 중복 갱신이 발생할 수 있습니다.

### 해결 방안

- 낙관적 락을 적용하여 중복 사용 방지
- 충돌 발생 시 재시도, 일정 횟수 초과 시 예외 처리

### 장단점 분석

- 장점:
- 주문 흐름과 분리된 트랜잭션 처리 가능 → 부분 실패 시 전체 주문 영향 없음
- 충돌 발생 시 유연한 재시도 및 롤백 가능
- 단점: 트랜잭션 분리에 따른 복잡도 증가, 장애 발생 시 디버깅 비용 증가

### 선택 배경
- 쿠폰 사용은 주문과는 독립된 도메인 행위이므로
  트랜잭션 전파 레벨을 REQUIRES_NEW로 설정하여 격리성 확보 및 유연한 롤백 처리를 가능하게 했습니다.
- 낙관적 락은 기본적으로 성능에 유리하지만,
  타이밍, 충돌 빈도, 재시도 조건이 맞지 않으면 동시성 제어가 실패하는 한계가 존재함.
  이를 보완하기 위한 아키텍처적 트레이드오프임
---

### 3.3 계좌 잔액 차감

- 격리 수준: `REPEATABLE READ`
- 전파 수준: `REQUIRED`

### 문제 상황: Lost Update

여러 결제 요청이 동시에 들어오면  
잔액 차감 연산이 중복될 수 있고, 일부 내역이 누락될 수 있습니다.

### 해결 방안

- `SELECT ... FOR UPDATE`를 통한 row-level 락 적용
- 조회, 차감, 저장을 하나의 트랜잭션으로 구성하여 원자성 확보

### 장단점 분석

- 장점: 금융 도메인의 데이터 정합성 확보 가능
- 단점: 트래픽 증가 시 처리량 저하 발생 여지 있음

---

## 주문 트랜잭션 흐름 설계

1. 재고 차감 (`FOR UPDATE`)
2. 쿠폰 사용 (`REQUIRES_NEW` + 낙관적 락)
3. 주문 생성
3. 생성된 주문 전체 금액 계좌 차감 (`FOR UPDATE`)
4. 결제 내역 저장

### 예외 처리 흐름

- 재고 차감 실패 시 쿠폰 사용 트랜잭션 롤백
- 잔액 부족 시 전체 주문/결제 롤백

---

## 추가 고려 사항

- 쿠폰과 같은 독립 처리 가능 도메인은 `REQUIRES_NEW` 트랜잭션 분리 고려
- 낙관적 락 충돌 대비 exponential backoff 전략 적용 가능
- 장애 대응을 위한 충돌/락 경합 지표 로깅 고려

---

## 결론

각 도메인의 트랜잭션 특성과 트래픽 패턴에 따라  
비관적 락과 낙관적 락을 적절히 혼용하여 데이터 정합성을 확보하였습니다.  
복잡한 연계 상황 속에서도 핵심 데이터의 안정성을 보장할 수 있도록  
트랜잭션 흐름과 예외 처리 전략을 유연하게 설계한 것이 이번 구조의 핵심입니다.
이 보고서는 실제 트래픽 부하 테스트 및 충돌 재현을 통해 도출된 개선 방향을 반영하였습니다.
특히 낙관적 락의 한계와 비관적 락 전환의 실효성,
그리고 독립 트랜잭션(REQUIRES_NEW) 분리를 통한 예외 처리 안정성 확보가 중요한 인사이트였습니다.