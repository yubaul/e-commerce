# 시스템 설계 및 개발 회고 보고서

(대상: 인기 상품 랭킹 시스템, 선착순 쿠폰 발급 대기열 시스템)

---

## 1. 인기 상품 랭킹 시스템

### 1.1 목표
- 최근 3일간의 판매 지표를 기반으로 Top 5 인기 상품을 신속히 조회합니다.
- 조회 시 DB 집계 비용을 최소화하고, Redis를 활용해 낮은 지연과 안정적인 성능을 확보합니다.

### 1.2 핵심 설계
- **일자별 랭킹 키**: `cash:item:rank:{yyyy-MM-dd}`  
  → Redis ZSET에 `member=itemId`, `score=판매량` 형태로 적재합니다.
- **3일 합산 캐시 키**: `cash:item:topSelling:last3days`  
  → `ZSetOperations#unionAndStore(k0, [k1, k2], UNION_CACHE_KEY)`로 오늘/어제/그제 랭킹을 합산합니다.  
  → 캐시 TTL은 **5분**입니다. (분 단위 갱신 주기)
- **Top 5 조회**: `reverseRangeWithScores(key, 0, 4)`로 상위 5개를 점수 포함으로 가져옵니다.

### 1.3 동작 흐름 (코드 기준)
- `ItemService#getTopSellingItems()`
    1. `ItemRankingReader#getTop5ItemsLast3Days()` 호출로 Redis 합산/캐시 조회
    2. 결과가 비어 있으면 빈 리스트 반환
    3. 랭킹 결과에서 `itemId` 목록을 추출하여 `ItemReader#getItems(ids)`로 DB 조회
    4. `ItemRankingMerger#merge(ranked, items)`로 **랭킹 정보 + 상품 메타(이름)**를 병합해 최종 응답
- `ItemRankingReaderImpl#getTop5ItemsLast3Days()`
    - 캐시 키(`cash:item:topSelling:last3days`)가 있으면 곧바로 `top5(..)` 반환
    - 없으면 오늘/어제/그제 키를 `unionAndStore`로 합산 후 TTL 5분 설정 → `top5(..)` 반환
- `ItemRankingMergerImpl#merge(..)`
    - DB에서 읽은 `List<Item>`을 `id → Item` 맵으로 만든 뒤, 랭킹 항목과 매칭하여  
      `itemId`, `itemName`, `salesVolume`을 담은 DTO(`ItemInfo.TopSelling`)를 생성합니다.

### 1.4 효과 및 특징
- **DB 집계 부하 제거**: 합산은 Redis ZSET 연산으로 수행하며, 결과를 5분 캐시합니다.
- **일관된 Top-N**: ZSET의 역정렬 조회로 상위 N개를 안정적으로 가져옵니다.
- **레이어 분리**:
    - `ItemRankingReader`는 읽기/캐시 책임
    - `ItemReader`는 상품 메타 조회 책임
    - `ItemRankingMerger`는 병합 책임  
      → 서비스 레이어(`ItemService`)는 **오케스트레이션**에 집중합니다.

### 1.5 회고
- 캐시 미스 시에도 Redis `unionAndStore` 1회로 합산을 끝낼 수 있어 **응답 지연을 최소화**할 수 있었습니다.
- 합산 캐시 TTL을 5분으로 두어 **신선도와 비용을 균형** 있게 가져갑니다.
- 랭킹 결과에 상품명을 더하기 위해 **DB 조회를 필요한 ID만 제한**하여 수행하는 점이 효율적입니다.

---

## 2. 선착순 쿠폰 발급 대기열 시스템

### 2.1 목표
- **전면 트래픽을 Redis에서 흡수**하여 선착순 정원을 공정하게 보장하고, 중복 발급을 차단합니다.
- 선착 통과자에 한해 **Redisson 기반 분산락**으로 DB의 **권위 데이터(재고/보유 쿠폰)**를 최종 확정합니다.

### 2.2 핵심 설계 (Redis 자료구조 및 키)
- **발급 한도**: `coupon:issue:queue:limit:{couponId}` — `RBucket<String>`에서 한도 값을 읽어 사용합니다.
- **입장 중복 가드(1회 입장권)**: `coupon:issue:queue:seen:{couponId}` — `RSet<String>`  
  → `seen.add(userId)`가 **처음만 true**가 되도록 하여 중복 입장을 차단합니다.
- **대기열**: `coupon:issue:queue:{couponId}` — `RScoredSortedSet<String>`  
  → 점수는 `RAtomicLong`(`coupon:issue:queue:seq:{couponId}`)의 `incrementAndGet()`로 부여합니다.  
  → 정원 초과 시 **꼬리(pollLast)**를 절단하여 처음 N명만 생존하도록 만듭니다.
- **최종 발급 미러(빠른 컷용)**: `coupon:issued:{couponId}` — `RSet<String>`  
  → DB 확정 성공 시 `markIssued`로 등록하여 **다음 요청에서 즉시 차단**합니다.
- **TTL 관리**: `seen`, `queue`, `seq`, `issued`는 **최초 생성 시 3일 TTL**을 설정합니다.

### 2.3 동작 흐름 (코드 기준)
#### (1) 서비스 단
- `CouponService#issueCouponToUser(command)`
    1. `queueGuard.assertNotIssued(couponId, userId)`  
       → 이미 발급자면 **예외**(`DuplicateCouponIssueException`)로 종료
    2. `queueGuard.tryEnter(couponId, userId)`  
       → **NX 가드**(seen)로 첫 입장만 허용  
       → **시퀀스 증가 + 큐 삽입**  
       → **정원 초과 보정**(while + pollLast)으로 처음 N명만 생존  
       → 본인이 잘리면 **예외**(`OutOfStockException`)
    3. **최종 확정 트랜잭션**
        - `couponFinalizer.finalizeIssue(couponId, userId)` 호출  
          (아래 “(2) 최종 확정” 참고)
        - 성공 시 `queueGuard.markIssued(couponId, userId)`로 **발급 미러** 등록
        - 실패 시 `queueGuard.freeSlot(couponId, userId)`로 **슬롯 복구** 후 예외 전파

#### (2) 최종 확정 (DB 권위, 분산락)
- `CouponFinalizerImpl#finalizeIssue(..)`에 `@CommonLock(key="coupon", id="#couponId")` 부여  
  → `CommonLockAop`가 **Redisson `RLock`**으로 `tryLock(wait, lease)` 수행  
  → 락 획득 후 `LockTransaction.proceed(joinPoint)`로 실제 비즈니스 실행
- 실제 비즈니스:
    - `CouponStockReader#getCouponStock(couponId)`로 현재 재고 조회
    - `couponStock.decrease(1)` 후 `CouponStockStore#store(..)`로 반영
    - `UserCouponStore#store(couponId, userId)` 시 **중복키 등**으로 `DataIntegrityViolationException` 발생하면  
      → `DuplicateCouponIssueException`을 변환 후 던짐

#### (3) Redis 게이트 구현 상세
- **중복 가드**: `addSeenWithTtl(couponId, userIdString)`
    - `seen.add(userId)`가 *처음*인 경우에만 `true` → 아니면 **중복 예외**
- **대기열 진입**:
    - `incrSeqWithTtl(couponId)`로 **단조 증가 score** 생성
    - `addQueueWithTtl(couponId, score, userIdString)`으로 **입장**
- **정원 초과 보정**:
    - `limitBucket.get()` 값을 정수로 파싱
    - `while (q.size() > limit) { q.pollLast(); }`
    - 방금 들어온 본인이 잘려나가면 `seen.remove(userId)` 후 **품절 예외**
- **발급 미러 등록**:
    - 최종 확정 성공 후 `markIssued(couponId, userId)`로 `issued.add(userId)` 저장
    - 이후 동일 유저 요청은 `assertNotIssued` 단계에서 **즉시 차단**

### 2.4 효과 및 특징
- **전면 트래픽을 Redis에서 처리**하여 DB까지 도달하는 요청을 **엄격히 선별**합니다.  
  (중복 시도/정원 초과는 **게이트에서 차단**)
- **선착순 공정성 보장**: 점수는 단조 증가 시퀀스로 부여하고, 초과 시 꼬리를 자르므로 **처음 N명만 생존**합니다.
- **권위 데이터는 DB**: 최종 확정(재고 차감 + 보유 쿠폰 기록)은 **분산락 하에 트랜잭션**으로 처리합니다.
- **보상 처리 명확화**: DB 확정 실패 시 `freeSlot`으로 큐/seen을 복구해 **슬롯 누수**를 방지합니다.
- **운영 편의**: Redis 키는 **최초 생성 시 3일 TTL**을 부여해 자연 소거됩니다.

### 2.5 회고
- **게이트(Admission)와 최종 확정(Commit)**을 분리함으로써 책임이 명확해졌습니다.  
  전자는 **속도/공정성/중복 차단**, 후자는 **일관성/권위 보장**에 집중합니다.
- `pollLast` 기반 초과 보정은 **동시성 경합에서도 처음 N명 보장**이라는 불변식을 유지합니다.
- 발급 미러(`coupon:issued:*`)를 운영함으로써 **중복 재시도 컷**이 빨라졌습니다.
- 한편, 발급 한도 버킷이 문자열로 저장된 환경에서는 **형 변환 주의**가 필요합니다.  
  (코드에서는 `RBucket<String>`을 사용하고 `trim() → parseInt`로 안전하게 처리합니다.)
- Redis 멤버 타입과 제거 시 타입 일관성(예: `queue.remove(..)`에 문자열 사용)은 **리뷰 및 테스트**로 지속 점검하는 것이 바람직합니다.

---

## 맺음말
- **인기 상품 랭킹**은 Redis ZSET과 `unionAndStore` 캐시를 통해 **신속·경량**으로 제공되며,
- **선착순 쿠폰 발급**은 Redis 게이트 → Redisson 분산락 → DB 확정의 단계로 **성능과 정합성**을 동시에 만족합니다.
- 본 구조는 트래픽이 급증하는 상황에서도 **낮은 지연, 높은 처리량, 데이터 일관성**을 실무적으로 달성할 수 있도록 설계되었습니다.
